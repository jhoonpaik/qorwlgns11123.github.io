---
title: 데이터 전처리
description: 데이터 분석과정에 있어서 활용가능한 데이터를 수집하는 과정만큼 중요한 과정이 바로 데이터 전처리 과정이다.
tags:
- preprocessing
- scaling
- encoding
categories:
- STUDY
---

# 데이터 전처리

데이터 분석과정에 있어서 활용가능한 데이터를 수집하는 과정만큼 중요한 과정이 바로 데이터 전처리 과정이다.
머신러닝 알고리즘은 데이터에 기반을 두고 있기 때문에 데이터 전처리 과정에 따라 상이한 결과가 나올 수 있다.
머신러닝에 적용하는 데이터에 결손값(NaN, Null)이 있으면 안 된다.
즉, 다른 값으로 변환하거나 제거해야 한다.
Null값을 처리하는 데 있어서 데이터의 특성이나 분석방향에 따라 다양한 방식이 있다.
만약 null값이 거의 없을 경우 피처의 평균값으로 간단히 대체할 수 있지만 null값이 대부분일 경우 해당되는 피처를 drop해야할 수도 있다.

하지만 이 null값이 많고 적고의 기준은 정해지지 않았고 또한, 피처의 중요도도 고려사항이기 때문에 상세하게 검토하여 더 정밀한 대체값을 선정해야할 수도 있다.

사이킷런에서는 문자열 값을 input으로 허용하지 않기 때문에 모든 문자열 값은 인코딩하여 수치형으로 변환해야 한다.
문자열 피처는 카테고리형 피처와 텍스트형 피처 두 가지가 있다.
- 카테고리형 피처: 범주형 피처
- 텍스트형 피처: 단순히 데이터를 식별하는 용도의 피처(불필요한 피처가 대부분임)

# 데이터 인코딩
머신러닝을 위한 대표적 인코딩 방식은 레이블 인코딩과 원핫 인코딩 방식이 있다.

## 레이블 인코딩
레이블 인코딩은 카테고리형 피처를 코드형 숫자값으로 변환하는 것이다.
예를 들어, TV, 냉장고, 컴퓨터 등의 범주형 데이터를 TV:1, 냉장고:2, 컴퓨터:3 이렇게 숫자형으로 변환한다.
만약 "01", "02"와 같은 코드 텍스트 범주형 데이터 역시 숫자형으로 변환해야 한다.

사이킷런의 레이블 인코딩은 LabelEncoder 클래스로 구현할 수 있다.
LabelEncoder 객체를 생성한 후 fit()과 transform()을 호출하여 인코딩을 수행한다.

```python
from sklearn.preprocessing import LabelEncoder

items= ['TV', '냉장고', '전자레인지', '컴퓨터', '선풍기', '선풍기', '믹서', '믹서']

# 객체생성
encoder = LabelEncoder()

encoder.fit(items)
labels = encoder.transform(items)
print('인코딩하여 변환한 값:', labels)
```
```
인코딩하여 변환한 값: [0 1 4 5 3 3 2 2]
```

해당 변환된 값이 어떤 문자열 값을 통해 변환되었는지는 classes_ 속성값으로 확인할 수 있다.
```python
print('인코딩 클래스', encoder.classes_)
```
```
인코딩 클래스 ['TV' '냉장고' '믹서' '선풍기' '전자레인지' '컴퓨터']
```

레이블 인코딩은 이렇게 간단하게 숫자형 카테고리 값으로 변환한다.
하지만 레이블 인코딩으로 인해 숫자형태의 값으로 변환되면서 머신러닝에 적용할 경우 숫자의 크고 작음에 대한 특성으로 인하여 예측 성능이 크게 저하될 수 있다. 즉, 믹서:2가 냉장고:1보다 더 큰 가중치가 부여되거나 중요하게 인식될 수 있는 가능성이 생긴다.
그러므로 레이블 인코딩은 선형회귀 가은 알고리즘에는 적용하며 안 된다. 다만 Tree 계열의 알고리즘은 숫자의 이러한 특성을 반영하지 않기 때문에 레이블 인코딩 적용시 문제가 없다.

## One Hot 인코딩
원핫 인코딩은 위와 같은 레이블 인코딩의 문제점을 해결하기 위한 인코딩 방식이다.
원핫 인코딩은 피처 값의 유형에 따라 새로운 피처를 추가하여 고유값에 해당하는 칼럼에만 1을 표시하고 나머지 칼럼에는 0을 표시하는 방식으로 인코딩이 진행된다.
![](https://velog.velcdn.com/images/adastra/post/f430e6d3-dd87-4ed4-b93d-270d37f31c57/image.png)

위의 그림을 보면 예를 들어 레코드의 상품분류가 TV인 경우에는 상품분류_TV 피처만 1이고 나머지 피처는 모두 0이다.  
이러한 특성을 가진 인코딩 방식이 바로 One-Hot(여러 개의 속성 중 단 한 개 속성만 1!) 인코딩이다.

원핫 인코딩은 OneHotEncoder 클래스로 쉽게 변환할 수 있다.
다만 변환하기 앞서 두 가지 조건이 있다.

1) 모든 문자열 값이 숫자형 값으로 변환되어 있어야 함  
2) 입력 값으로 2차원 데이터가 필요함

```python
from sklearn.preprocessing import OneHotEncoder
import numpy as np
items = ['TV', '냉장고', '전자레인지', '컴퓨터', '선풍기', '선풍기', '믹서', '믹서']

# 숫자값 변환을 위해 LabelEncoder로 변환
encoder = LabelEncoder()
encoder.fit(items)
labels = encoder.transform(items)

# 2차원 데이터로 변환
labels = labels.reshape(-1, 1)

# 원핫 인코딩 적용
oh_encoder = OneHotEncoder()
oh_encoder.fit(labels)
oh_labels = oh_encoder.transform(labels)

print('원-핫 인코딩 데이터')
print(oh_labels.toarray())
print('원-핫 인코딩 데이터 차원')
print(oh_labels.shape)
```

![](https://velog.velcdn.com/images/adastra/post/7ac6f126-0582-4d3e-b049-4b470dd9b149/image.png)

8개의 레코드와 1개의 컬럼을 가진 원본데이터가 위와 같이 8개의 레코드와 6개의 칼럼을 가지 데이터로 변환되었다.
이러한 인코딩 절차는 아래의 그림과 같이 정리할 수 있다.

![](https://velog.velcdn.com/images/adastra/post/6f2e3a16-523b-4563-b454-10276968c3da/image.png)

판다스에는 원핫 인코딩을 더 쉽게 지원하는 API가 있다.
get_dummies()함수를 이용하면 문자열 카테고리 값을 숫자형을 변환할 필요없이 바로 변환할 수 있다.

```python
import pandas as pd
df = pd.DataFrame({'item':['TV', '냉장고', '전자레인지', '컴퓨터', '선풍기', '선풍기', '믹서', '믹서']})
pd.get_dummies(df)
```

![](https://velog.velcdn.com/images/adastra/post/132d4b5c-3534-4750-8e8d-bd339a117d6d/image.png)

# feature scaling
서로 다른 변수의 값 범위를 일정한 수준으로 맞추는 작업을 피처 스케일링이라고 한다.

## 표준화(Standardization)와 정규화(Normalization)
피처 스케일링의 대표적인 방법은 표준화(Standardization)와 정규화(Normalization)가 있다.

### 표준화
표준화는 데이터의 피처 각각이 평균이 0, 분산이 1인 가우시안 정규분포를 가진 값으로 변환하는 방식이다.
표준화를 통해 변환될 피처x의 새로운 i번째 데이터를 xi_new라고 할 경우
이 값은 원래 값에서 피처x의 평균을 뺀 값을 피처x의 표준편차로 나눈 값으로 계산할 수 있다.
![](https://velog.velcdn.com/images/adastra/post/f4c902bf-7f82-4e82-b2d2-ee496b1a723f/image.png)

### 정규화
정규화는 서로 다른 피처의 크기를 통일하기 위해 크기를 변환하는 개념이다.
예를 들어 거리값인 피처 A가 0-100km 이고 금액값인 피처 B가 0-100,000,000원일 경우 이 변수들을 모두 동일한 크기의 단위로 비교하기 위해 모두 0~1의 값으로 변환하는 것이다.

새로운 데이터xi_new는 원래 값에서 피처x의 최소값을 뺀 값을 피처 x의 최대값, 최소값의 차이로 나눈 값으로 변환할 수 있다.
![](https://velog.velcdn.com/images/adastra/post/33544a96-3665-4d42-b677-4bd5b80b0d23/image.png)

하지만 사이킷런의 전처리에서 제공하는 Normalizer 모듈과 일반적인 정규화는 차이가 있다.
사이킷런의 Normalizer 모듈은 선형대수의 정규화 개념이 적용됬으며, 개별 벡터의 크기를 맞추기 위해 변환하는 방식이다.

즉,  세 개의 피처 x, y, z가 있다면 새로운 데이터 xi_new는 원래 값에서 세 개의 피처의 i번째 피처값에 해당하는 크기를 합한 값으로 나눠준다.
![](https://velog.velcdn.com/images/adastra/post/9b186f50-e1a8-4813-8b18-0fee211e218b/image.png)

## 사이킷런 피처 스케일링 클래스
일반적인 의미의 표준화, 정규화를 피처스케일링으로 선형대수 개념 정규화를 벡터정규화로 지칭하고 사이킷런에서 제공하는 피처 스케일링 클래스인 StandardScaler와 MinMaxScaler에 대해 알아보자

### StandardScaler
StandardScaler는 표준화를 쉽게 지원하기 위한 클래스로 개별 피처를 평균이 0, 분산이 1인 값으로 변화해준다.
StandardScaler가 어떻게 데이터값을 변환하는지 데이터셋을 통해 확인해보자

```python
from sklearn.datasets import load_iris
import pandas as pd

# 붓꽃데이터셋 로딩
iris = load_iris()
iris_data = iris.data

# df로 변환
iris_df = pd.DataFrame(data=iris_data, columns=iris.feature_names)

print('feature들의 평균값')
print(iris_df.mean())
print('\nfeature들의 분산값')
print(iris_df.var())
```

```
feature들의 평균값
sepal length (cm)    5.843333
sepal width (cm)     3.057333
petal length (cm)    3.758000
petal width (cm)     1.199333
dtype: float64

feature들의 분산값
sepal length (cm)    0.685694
sepal width (cm)     0.189979
petal length (cm)    3.116278
petal width (cm)     0.581006
dtype: float64
```

StandardScaler를 통해 각 피처를 한 번에 표준화해보자
```python
from sklearn.preprocessing import StandardScaler

# StandardScaler 객체 생성
scaler = StandardScaler()

# StandardScaler로 데이터셋 변환
scaler.fit(iris_df)
iris_scaled = scaler.transform(iris_df)

# transform() 적용되어 스케일 변환된 데이터셋이 ndarray로 반환됬으므로 이를 df로 변환
iris_df_scaled = pd.DataFrame(data=iris_scaled, columns = iris.feature_names)
print('feature 들의 평균값')
print(iris_df_scaled.mean())
print('\nfeature 들의 분산값')
print(iris_df_scaled.var())
```

```
feature 들의 평균값
sepal length (cm)   -1.690315e-15
sepal width (cm)    -1.842970e-15
petal length (cm)   -1.698641e-15
petal width (cm)    -1.409243e-15
dtype: float64

feature 들의 분산값
sepal length (cm)    1.006711
sepal width (cm)     1.006711
petal length (cm)    1.006711
petal width (cm)     1.006711
dtype: float64
```

모든 컬럼의 평균이 0에 아주 가까운 값, 분산이 1에 아주 가까운 값으로 변환된 것을 확인할 수 있다.

### MinMaxScaler
MinMaxScaler는 데이터값을 0과 1사이의 범위 값으로 변환한다.  
(음수값이 있으면 -1에서 1값으로 변환한다.)  
데이터의 분포가 가우시안 분포가 아닌 경우 Min, Max Scale을 적용해볼 수 있다.

```python
from sklearn.preprocessing import MinMaxScaler

# MinMaxScaler 객체 생성
scaler = MinMaxScaler()

# MinMaxScaler로 데이터셋 변환, fit(), transform() 호출
scaler.fit(iris_df)
iris_scaled = scaler.transform(iris_df)

# transform() 적용되어 스케일 변환된 데이터셋이 ndarray로 반환됬으므로 이를 df로 변환
iris_df_scaled = pd.DataFrame(data=iris_scaled, columns = iris.feature_names)
print('feature 들의 최소값')
print(iris_df_scaled.min())
print('\nfeature 들의 최대값')
print(iris_df_scaled.max())
```

```
feature 들의 최소값
sepal length (cm)    0.0
sepal width (cm)     0.0
petal length (cm)    0.0
petal width (cm)     0.0
dtype: float64

feature 들의 최대값
sepal length (cm)    1.0
sepal width (cm)     1.0
petal length (cm)    1.0
petal width (cm)     1.0
dtype: float64
```

모든 피처에 0~1 사이의 값으로 변환되는 스케일링이 적용된 것을 확인할 수 있다.

> 참고자료: 파이썬 머신러닝 완벽 가이드 - 권철민